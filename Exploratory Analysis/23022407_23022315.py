# -*- coding: utf-8 -*-
"""Atividade_Analise_Exploratoria

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l7Fa0IFhOsM43JoGe6GTxT8M0AAAlmXn

Curso : Ci√™ncia de Dados

Alunas: Camila Perazzo e Sara Coutinho.

Atividade de Analise Exploratoria - 17/04/2023.

Para arquivo propostas de solu√ßoes (Diario de Bordo): 

* 6/4/23: 10:30 √†s 11:00 - Reuniao de Alinhamento

* 8/4/23: 8:30 √†s 9:30 -  Compreensao das atividades, entendimento do negocio, coleta dos dados 
* 10/4/23: 17:00 √†s 19 - Amostragem
* 15/4/23 : 13:30 √†s 14:30 - Corre√ßao de arquivo e ajustes dos calculos preenchimento valores nulos
* 16/4/23: 18:00 √†s 20:00
* 17/4/23: 17:30 √†s 23:00

Com base no ciclo de vida do projeto de Data Science, seguiremos as seguintes etapas: 


*   Entendimento do Neg√≥cio
*   Coleta dos Dados
*   Prepara√ß√£o dos dados
*   An√°lise Explorat√≥ria

Conforme o exerc√≠cio proposto, segue abaixo a lista descrevendo onde cada quest√£o foi resolvida: 

1) Prepara√ß√£o dos dados - Est√° na etapa de prepara√ß√£o dos dados 

2) Amostragem - Est√° na etapa de An√°lise Explorat√≥ria 

3) Correla√ß√£o das vari√°veis - Est√° na etapa de An√°lise Explorat√≥ria 

4) Estat√≠stica descritiva - Est√° na etapa de An√°lise Explorat√≥ria

# üí∞ Entendimento do neg√≥cio

Com isso, seguimos com as etapas de entendimento do neg√≥cio, coleta, prepara√ß√£o e an√°lise. Para o entendimento do neg√≥cio, aplicamos o 5W2H: What, Who, Where, When, Why, How, How Much. 


* *What* - **Monitoramento de sinais vitais**. 


* *Where* - N√£o definido. 


* *When* - Deadline da atividade. 


* *Who* - Reportar para o professor da disciplina.


* *Why* - O monitoramento de sinais vitais √© importante para a manuten√ß√£o da sa√∫de da popula√ß√£o. 


* *How* - A partir de dados obtidos por sensores, a respeito dos sinais vitais, √© poss√≠vel detectar padr√µes de comportamentos normais dos pacientes a partir de data mining e fazer o monitoramento da sa√∫de dos pacientes. 


* *How much* - N√£o definido, mas a parte de custo seria relativo ao custo para obten√ß√£o do arquivo com dados.

Conforme passado na quest√£o, as vari√°veis dos dados s√£o as descritas abaixo e com os respectivos limites de varia√ß√£o:

**0<= BATIMENTO CARD√çACO < 100**

**0<= PRESS√ÉO ARTERIAL < 20**

**0<= TEMPERATURA CORPORAL < 40**

# üé≤ Coleta dos dados

Como os dados trabalhados s√£o de batimento card√≠aco, press√£o arterial e temperatura corporal, espera-se que eles sejam dados quantitativos cont√≠nuos para as 3 vari√°veis, pois dessa forma ser√° poss√≠vel fazer as previs√µes e classificar o paciente entre saud√°vel ou n√£o saud√°vel.

O arquivo que usamos foi com termina√ß√£o 7.
"""

#imports
import pandas as pd #dataframe 
import numpy as np 

#Entendendo os dados do arquivo
file = pd.read_table('/content/sinaisvitais003 100dias DV2 RAxxx7.txt')
file.head(5)

file.describe()

"""Compreende-se que a primeira coluna corresponde ao batimento card√≠aco, a segunda a press√£o arterial e a terceira a temperatura corporal pela descri√ß√£o dos valores. Os dados ser√£o ajustados para nomear as colunas de acordo com as vari√°veis as quais eles correspondem."""

#CSV para dataframe
data = pd.read_csv('/content/sinaisvitais003 100dias DV2 RAxxx7.txt', sep='\t',names=['Batimento','Pressao','Temperatura'])

#data=list(d)
#visualizando os dados
data

"""Os dados sao quantitativos continuos.

# üé≤  Prepara√ß√£o dos Dados

## 1) Prepara√ß√£o dos Dados 


* 1.1 ) Detec√ß√£o dos valores fora das faixas normais
* 1.2 ) substitui√ß√£o caso n√£o sejam
"""

#verifica√ßao dos tipos de dados
data.info()

"""Os valores j√° est√£o em formato float que comporta n√∫meros reais. Ser√° verificada a exist√™ncia de valores fora dos limites para serem tratados na etapa de prepara√ß√£o. """

#verifica√ßao da exist√™ncia de valores nulos
data.isnull().sum()

#verifica√ßao da exist√™ncia de valores duplicados
data.duplicated().sum()

"""Como nao exist√™m valores nulos nem duplicados, sera feito o ajuste sobre os valores fora dos limites conforme proposto no exercicio. """

count_batimento = 0
lista_batimento = []
count_pressao = 0
lista_pressao = []
count_temperatura = 0
lista_temperatura = []
for column in data.columns:
  if column == 'Batimento':
    for element in data['Batimento']:
      if (element < 0) or (element > 99):
        count_batimento +=1
        lista_batimento.append(element)
  elif column == 'Pressao':
    for  element in data['Pressao']:
      if (element < 0) or (element > 19):
        count_pressao +=1
        lista_pressao.append(element)
  elif column == 'Temperatura':
    for element in data['Temperatura']:
      if (element < 0) or (element > 39):
        count_temperatura +=1 
        lista_temperatura.append(element)

print('O total de valores fora dos limites superior e inferior para o batimento sao: ',
      count_batimento,' para a pressao: ',count_pressao,' e para a temperatura: ',count_temperatura,'.')

print('Os valores fora dos limites sao: para o batimento',lista_batimento,'para a pressao: ',lista_pressao,' e para a temperatura: ',lista_temperatura,'.')

#imputando a m√©dia

#novo dataframe para imputar valores
data_tratamento = data.copy()
data_tratamento['Hora']=data.index
data_tratamento = data_tratamento.reset_index()

#verificando index dos dados que estao fora do limite 
#batimento : [102.04258102773412, 102.26050962071476, 101.84662280012496]
print('Batimento')
print(data_tratamento[data_tratamento['Batimento']==102.04258102773412].index)
print(data_tratamento[data_tratamento['Batimento']==102.26050962071476].index)
print(data_tratamento[data_tratamento['Batimento']==101.84662280012496].index)
#pressao : [21.460717379976344, 22.874284301610945, 21.937331982410303
print('Pressao')
print(data_tratamento[data_tratamento['Pressao']==21.460717379976344].index)
print(data_tratamento[data_tratamento['Pressao']==22.874284301610945].index)
print(data_tratamento[data_tratamento['Pressao']==21.937331982410303].index)
#temperatura : [41.91530397736243, 41.727868474442296, 41.01128458809205] 
print('Temperatura')
print(data_tratamento[data_tratamento['Temperatura']==41.91530397736243].index)
print(data_tratamento[data_tratamento['Temperatura']==41.727868474442296].index)
print(data_tratamento[data_tratamento['Temperatura']==41.01128458809205].index)

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# #imputando valores nulos para bfill 
# data_tratamento_bfill = data_tratamento.copy()
# 
# #imputando valores nulos para ffill 
# data_tratamento_ffill = data_tratamento.copy()
# 
# #inputando valores nulos nos campos em que eles estao fora dos limites considerados 
# data_tratamento_bfill['Batimento'].loc[479], data_tratamento_bfill['Batimento'].loc[1022], data_tratamento_bfill['Batimento'].loc[2388] = None, None, None
# data_tratamento_bfill['Pressao'].loc[491], data_tratamento_bfill['Pressao'].loc[1028], data_tratamento_bfill['Pressao'].loc[2388] = None, None, None
# data_tratamento_bfill['Temperatura'].loc[515], data_tratamento_bfill['Temperatura'].loc[1032], data_tratamento_bfill['Temperatura'].loc[2395] = None, None, None
# 
# data_tratamento_ffill['Batimento'].loc[479], data_tratamento_ffill['Batimento'].loc[1022], data_tratamento_ffill['Batimento'].loc[2388] = None, None, None
# data_tratamento_ffill['Pressao'].loc[491], data_tratamento_ffill['Pressao'].loc[1028], data_tratamento_ffill['Pressao'].loc[2388] = None, None, None
# data_tratamento_ffill['Temperatura'].loc[515], data_tratamento_ffill['Temperatura'].loc[1032], data_tratamento_ffill['Temperatura'].loc[2395] = None, None, None
# 
# #preenchendo com bfill
# data_tratamento_bfill=data_tratamento_bfill.fillna(method='bfill')
# #preenchendo com ffill
# data_tratamento_ffill=data_tratamento_ffill.fillna(method='ffill')
# 
#

#verificando valores preenchidos a partir dos dados anteriores 
print(data_tratamento_bfill['Batimento'].loc[479],data_tratamento_bfill['Batimento'].loc[1022],data_tratamento_bfill['Batimento'].loc[2388])
print(data_tratamento_bfill['Pressao'].loc[491],data_tratamento_bfill['Pressao'].loc[1028],data_tratamento_bfill['Pressao'].loc[2388])
print(data_tratamento_bfill['Temperatura'].loc[515],data_tratamento_bfill['Temperatura'].loc[1032],data_tratamento_bfill['Temperatura'].loc[2395])

#verificando valores preenchidos a partir dos dados posteriores
print(data_tratamento_ffill['Batimento'].loc[479],data_tratamento_ffill['Batimento'].loc[1022],data_tratamento_ffill['Batimento'].loc[2388])
print(data_tratamento_ffill['Pressao'].loc[491],data_tratamento_ffill['Pressao'].loc[1028],data_tratamento_ffill['Pressao'].loc[2388])
print(data_tratamento_ffill['Temperatura'].loc[515],data_tratamento_ffill['Temperatura'].loc[1032],data_tratamento_ffill['Temperatura'].loc[2395])

#calculando a m√©dia dos valores para preencher para batimento 
print(((65.83949936926456+70.51424189025641)/2),((73.23914035693186+72.28910224751941)/2),((69.2668742131401+68.38246614554963)/2))

#calculando a m√©dia dos valores para preencher para pressao 
print(((13.64436758778996+13.03212277006944)/2),((12.8877833854140236+12.847844308182204)/2),((13.175725485356317+12.864476463680672)/2))

#calculando a m√©dia dos valores para preencher para temperatura 
print(((37.02389585493685+36.97653996339061)/2),((36.7594016329112+36.50396737117941)/2),((37.11786513281035+37.05925529482506)/2))

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# #inputando os valores no conjunto de dados tratamento 
# data_tratamento['Batimento'].loc[479], data_tratamento['Batimento'].loc[1022], data_tratamento['Batimento'].loc[2388] = None, None, None
# data_tratamento['Pressao'].loc[491], data_tratamento['Pressao'].loc[1028], data_tratamento['Pressao'].loc[2388] = None, None, None
# data_tratamento['Temperatura'].loc[515], data_tratamento['Temperatura'].loc[1032], data_tratamento['Temperatura'].loc[2395] = None, None, None

#verificando os valores nulos nas colunas do dataframe de tratamento 
data_tratamento.isnull().sum()

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# #inputando os valores de m√©dia do valor anterior com o posterior no conjunto de dados tratamento 
# data_tratamento['Batimento'].loc[479], data_tratamento['Batimento'].loc[1022], data_tratamento['Batimento'].loc[2388] = 68.17687062976049, 72.76412130222563, 68.82467017934486
# data_tratamento['Pressao'].loc[491], data_tratamento['Pressao'].loc[1028], data_tratamento['Pressao'].loc[2388] = 13.3382451789297, 12.867813846798114, 13.020100974518495
# data_tratamento['Temperatura'].loc[515], data_tratamento['Temperatura'].loc[1032], data_tratamento['Temperatura'].loc[2395] = 37.00021790916373, 36.6316845020453, 37.0885602138177

#verificando se os valores foram imputados corretamente no dataframe criado pra tratamento
data_tratamento.isnull().sum()

#substituindo os dados do dataframe data pelos dados do dataframe tratado
data = data_tratamento

#verificando novamente a  exist√™ncia de valores dentro dos limites 

count_batimento = 0
lista_batimento = []
count_pressao = 0
lista_pressao = []
count_temperatura = 0
lista_temperatura = []
for column in data.columns:
  if column == 'Batimento':
    for element in data['Batimento']:
      if (element < 0) or (element > 99):
        count_batimento +=1
        lista_batimento.append(element)
  elif column == 'Pressao':
    for  element in data['Pressao']:
      if (element < 0) or (element > 19):
        count_pressao +=1
        lista_pressao.append(element)
  elif column == 'Temperatura':
    for element in data['Temperatura']:
      if (element < 0) or (element > 39):
        count_temperatura +=1 
        lista_temperatura.append(element)  

print('O total de valores fora dos limites superior e inferior para o batimento sao: ',
      count_batimento,' para a pressao: ',count_pressao,' e para a temperatura: ',count_temperatura,'.')

"""Todos os valores estao dentro dos limites. """

#verificando se os valores foram imputados corretamente no dataframe criado pra tratamento
data.isnull().sum()

"""Nao existem valores nulos. """

data_tratamento.duplicated().sum()

"""Existem 3 dados com medi√ß√µes de batimento fora dos limites, 3 de press√£o e 3 de temperatura. Esses valores ser√£o retirados. """

#verificando o shape final do conjunto de dados 
data.shape

data = data.set_index('index')
data = data.drop(columns=['Hora'])
data.shape

"""# üé≤ An√°lise Explorat√≥ria dos Dados

## 2 ) Divisao do arquivo em amostras e Correla√ßao das Variaveis.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

tamanho_pacote = 24  # Tamanho desejado para cada pacote
pacotes = []  # Lista para armazenar os pacotes

# Selecionar apenas as colunas desejadas
dados_selecionados = data[['Batimento', 'Pressao', 'Temperatura']]

# Dividir os dados em pacotes de tamanho 'tamanho_pacote'
for i in range(0, len(dados_selecionados), tamanho_pacote):
    pacote = dados_selecionados.iloc[i:i+tamanho_pacote].reset_index(drop=True)
    pacotes.append(pacote)

pacotes

"""No final ficaram 2400 inst√¢ncias e 3 colunas.

Visualiza√ß√£o da evolu√ßao das correla√ßoes entre as vari√°veis ao decorrer dos dias.
"""

# Calcula a matriz de correla√ß√£o da variavel pelo dia(pacote)
matrizes_corr = []
for pacote in pacotes:
    matriz_corr = pacote.corr()
    matrizes_corr.append(matriz_corr)

# Plota um gr√°fico de linhas com a evolu√ß√£o das correla√ß√µes de cada par√¢metro
parametros = ['Batimento', 'Pressao', 'Temperatura']
cores = ['r', 'g', 'b', 'y']
for i, parametro in enumerate(parametros):
    plt.plot(range(len(pacotes)), [matriz_corr.loc[parametro].mean() for matriz_corr in matrizes_corr], color=cores[i], label=parametro)
plt.xlabel('Dias')
plt.ylabel('Correla√ß√£o')
plt.title('Evolu√ß√£o das correla√ß√µes por dia e par√¢metro')
plt.legend()
plt.show()

"""Por esse grafico concluimos que os valores do batimento e pressao estao mais proximos entre si e crescem e decrescem semelhantemente no decorrer dos dias. Al√©m disso, √© observado um decrescimento dos valores de correla√ßoes de Batimento e pressao quando os dias se aproximam de 100. 
Ja a correla√ßao da temperatura possui valores mais distantes das demais correla√ßoes obtidas e ao inv√©s de decrescer proximo aos 100 dias, a correla√ßao cresce. Isso indica que as medi√ßoes de temperatura cresceram no decorrer do tempo. Ja as de batimento e pressao nao.

Analisando o comportamento das variaveis por Hora, construimos a matriz de correla√ßao de cada variavel entre si dentro dos grupos de amostras de tamanho 100 por cada Hora.
"""

#Analisando a correla√ßao por grupos de amostras por hora ao inv√©s de dia 
data['index'] = data.index
df = data.groupby(by=data['index'])

df.corr()

#Analisando a m√©dia de cada variavel por Hora
df.mean()

#Analisando a m√©dia de cada variavel por Hora
df.mean().corr()

# Plota um gr√°fico de linhas com a evolu√ß√£o das correla√ß√µes de cada par√¢metro
parametros = ['Batimento', 'Pressao', 'Temperatura']
cores = ['r', 'g', 'b', 'y']
for i, parametro in enumerate(parametros):
    plt.plot(df.mean().index, df.mean()[parametro], color=cores[i], label=parametro)
plt.xlabel('Horas')
plt.ylabel('Correla√ß√£o')
plt.title('Evolu√ß√£o das correla√ß√µes por Hora e par√¢metro')
plt.legend()
plt.show()

"""Por esse grafico vemos que a correla√ßao do valor m√©dio das variaveis Batimento e Pressao apresentam tamb√©m um comportamento semelhante por Hora. Em contrapartida, o valor m√©dio da Temperatura apresenta um comportamento constante por Hora.

Comparando o comportamento das variaveis considerando as amostras por dia e as amostras por hora, concluiu-se que em ambos os casos tanto o Batimento quanto a Pressao possuiram comportamentos semelhantes. Em compensa√ßao, a Temperatura decresceu ao longo dos dias. Contudo, a temperatura se mostrou constante ao longo das horas. 

Em termos praticos, √© interessante que o paciente averigue sua temperatura dia apos dia ja que esse √© um fator que varia por dia, mas nao importa a hora do dia em que ela for medida. Al√©m disso, a hora do dia que o batimento e a pressao apresentam um aumento sao em torno das 15 √†s 20 horas do dia. Por isso, √© importante ter em mente essa possivel varia√ßao existente ao longo do dia tamb√©m no processo de medi√ßao dessas variaveis no paciente.

Para analisar os dados no geral, plotou-se uma matriz sem considerar o processo de amostragem. Foi utilizada a correla√ßao de sperman a fim de que nao se assumisse um comportamento linear apriori das variaveis.
"""

# plot da matriz de correla√ß√£o
from  matplotlib.colors import LinearSegmentedColormap
cmap=LinearSegmentedColormap.from_list('rg',["r", "w", "g"], N=256) 
#cmap = sb.cm.rocket_r
plot = sb.heatmap(data[['Batimento', 'Pressao', 'Temperatura']].corr('spearman'), annot = True, fmt=".1f", linewidths=.6, cmap=cmap)

"""Nessa matriz tamb√©m percebe-se que as variaveis Pressao e Batimento sao fortemente correlacionadas enquanto que com a Temperatura a correla√ßao delas √© mais fraca."""

# Plota um gr√°fico de linhas cdo comportamento entre Batimento e Pressao
cor = ['r']
plt.plot(df.mean()['Batimento'], df.mean()['Pressao'], color=cores[i], label='Pressao')
plt.xlabel('Batimento')
plt.ylabel('Pressao')
plt.title('Batimento x Pressao')
plt.legend()
plt.show()

df.mean()['Batimento'].corr(df.mean()['Pressao'])

"""De fato, as variaveis apresentam um comportamento praticamente linear e com tend√™ncia crescente confirmando a correla√ßao forte e positiva das variaveis.

## 3 ) Composi√ßao de Correla√ßoes

Conforme visto na questao 2, as correla√ßoes mais fortes sao Batimento e Pressao. Considerou-se verificar o novo padrao de aprendizado a partir da correla√ßao dessas duas variaveis.
"""

df[['Batimento','Pressao']].corr()

#correla√ßao pressao e batimento
corr_p_b = [0.310437,0.439939,0.266013,0.494477,0.422689,0.421179,0.259059,0.457953,0.380042,0.571576,0.382157,0.390961,
            0.347614,0.395263,0.529469,0.411296,0.322504,0.328234,0.450366,0.482602,0.378035,0.317582,0.479318,0.526581]

# Plota um gr√°fico de linhas com a evolu√ß√£o das correla√ß√µes de cada par√¢metro
parametros = ['Batimento', 'Pressao', 'Temperatura']
cores = ['r', 'g', 'b', 'y']
for i, parametro in enumerate(parametros):
    plt.plot(df.mean().index, df.mean()[parametro], color=cores[i], label=parametro)
plt.plot(corr_p_b,color='skyblue',label='Correla√ßao Batimento x Pressao')
plt.xlabel('Horas')
plt.ylabel('Correla√ß√£o')
plt.title('Evolu√ß√£o das correla√ß√µes por Hora e par√¢metro')
plt.legend()
plt.show()

"""Nesse grafico observa-se que a correla√ßao entre Batimento e Pressao por hora resultou numa curva praticamente reta, nao demonstrando o comportamento dessas variaveis. Por isso, pode ser mais interessante utilizar uma das variaveis para representar as duas, ja que elas estao fortemente correlacionadas, do que utilizar a correla√ßao delas para o aprendizado. Al√©m disso, √© importante notar que essa correla√ßao nao muda com o tempo, confirmando que pode valer a pena utilizar apenas uma delas pra medi√ßao ao longo do tempo. 

No caso pratico, poderia-se medir apenas a pressao ou o batimento do paciente e a partir disso constatar a saude do paciente com rela√ßao a essas duas variaveis observando apenas uma delas, em termos de hora. 
"""

tamanho_pacote = 24  # Tamanho desejado para cada pacote
pacotes = []  # Lista para armazenar os pacotes

# Selecionar apenas as colunas desejadas
dados_selecionados = data[['Batimento', 'Pressao']]

# Dividir os dados em pacotes de tamanho 'tamanho_pacote'
for i in range(0, len(dados_selecionados), tamanho_pacote):
    pacote = dados_selecionados.iloc[i:i+tamanho_pacote].reset_index(drop=True)
    pacotes.append(pacote)

# Calcula a matriz de correla√ß√£o da variavel pelo dia(pacote)
matrizes_corr = []
for pacote in pacotes:
    matriz_corr = pacote.corr()
    matrizes_corr.append(matriz_corr)

matrizes_corr

# Plota um gr√°fico de linhas com a evolu√ß√£o das correla√ß√µes de cada par√¢metro
plt.plot(range(len(pacotes)), [matriz_corr.loc['Batimento', 'Pressao'].mean() for matriz_corr in matrizes_corr], color='skyblue', label='Correlacao Batimento x Pressao')
plt.xlabel('Dias')
plt.ylabel('Correla√ß√£o')
plt.title('Evolu√ß√£o das correla√ß√µes Batimento x Pressao por dia')
plt.legend()
plt.show()

"""No caso da m√©dia correla√ßao Batimento x Pressao por dia, observou-se um decrescimento desse valor ao longo dos dias. Na tabela de correla√ßoes tamb√©m √© verificado que as correla√ßoes dos primeiros dias sao maiores e dos ultimos dias menores. Apesar das variaveis serem fortemente correlacionadas no geral e em amostras por hora, quando analisadas por dia possuem um decrescimento na correla√ßao. 

Em termos praticos, isso pode ser importante na analise do paciente, pois ao passar dos dias, pode ser preciso mensurar as 3 variaveis, uma vez que a correla√ßao entre as duas mais fortes decai.

## 4 ) Ferramental Descritivo

Nessa etapa foram verificados os resultados para as medidas de posi√ßao (m√©dia, moda, mediana, histograma) e medidas de dispersao (variancia e desvio padrao).
"""

#Imports 
import statistics as stats #Medidas de posi√ßao e dispersao
from collections import Counter #Medidas de posicao e dispersao
import seaborn as sb #plot correla√ßao

data.drop(columns=['index']).describe()

"""Esta tabela apresenta os valores obtidos para a m√©dia de cada variavel na linha denominada mean. """

#Calculo mediana 
print('Mediana batimento: ',round(stats.median(data['Batimento']),2))
print('Mediana Pressao: ',round(stats.median(data['Pressao']),2))
print('Mediana Temperatura: ',round(stats.median(data['Temperatura']),2))

#Calculo moda - valida por dia 
print('Moda batimento: ',round(stats.mode(data['Batimento']),2))
print('Moda Pressao: ',round(stats.mode(data['Pressao']),2))
print('Moda Temperatura: ',round(stats.mode(data['Temperatura']),2))

"""Sao apresentados tamb√©m os valores de mediana e moda. Nas 3 variaveis tanto m√©dia, quanto mediana e moda sao valores proximos.

A seguir √© verificado o comportamento da m√©dia e da mediana ao longo dos dias para as 3 varivaeis.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# tamanho_pacote = 24  # Tamanho desejado para cada pacote
# pacotes = []  # Lista para armazenar os pacotes
# 
# # Selecionar apenas as colunas desejadas
# dados_selecionados = data[['Batimento', 'Pressao', 'Temperatura']]
# 
# # Dividir os dados em pacotes de tamanho 'tamanho_pacote'
# for i in range(0, len(dados_selecionados), tamanho_pacote):
#     pacote = dados_selecionados.iloc[i:i+tamanho_pacote].reset_index(drop=True)
#     pacotes.append(pacote)
# 
# pacotes
#

medias_batimento = []  # lista para armazenar as m√©dias de batimento de cada pacote
median_batimento = []
for pacote in pacotes:
    media_pacote = pacote['Batimento'].mean()  # calcula a m√©dia da coluna 'batimento' do pacote atual
    medias_batimento.append(media_pacote)
    median_pacote = pacote['Batimento'].median()  # calcula a m√©dia da coluna 'temperatura' do pacote atual
    median_batimento.append(median_pacote) 
indices_pacotes = range(len(pacotes))# Cria um eixo x com os √≠ndices dos pacotes
plt.plot(indices_pacotes, medias_batimento,color='b',label='M√©dia')# Plote o gr√°fico de linha
plt.plot(indices_pacotes, median_batimento,color='y',label='Mediana')
plt.title("M√âTRICAS AO DECORRER DOS 100 DIAS")
plt.legend()
plt.xlabel("DIA")
plt.ylabel("BATIMENTO")

medias_pressao = []  # lista para armazenar as m√©dias de batimento de cada pacote
median_pressao = []
for pacote in pacotes:
    media_pacote = pacote['Pressao'].mean()  # calcula a m√©dia da coluna 'batimento' do pacote atual
    medias_pressao.append(media_pacote)
    median_pacote = pacote['Pressao'].median()  # calcula a m√©dia da coluna 'pressao' do pacote atual
    median_pressao.append(median_pacote) 
indices_pacotes = range(len(pacotes))# Cria um eixo x com os √≠ndices dos pacotes
plt.plot(indices_pacotes, medias_pressao,color='b',label='M√©dia')# Plote o gr√°fico de linha
plt.plot(indices_pacotes, median_pressao,color='y',label='Mediana')
plt.title("M√âTRICAS AO DECORRER DOS 100 DIAS")
plt.legend()
plt.xlabel("DIA")
plt.ylabel("PRESSAO")

medias_temperatura = []  # lista para armazenar as m√©dias de temperatura de cada pacote
median_temperatura = []
for pacote in pacotes:
    media_pacote = pacote['Temperatura'].mean()  # calcula a m√©dia da coluna 'temperatura' do pacote atual
    medias_temperatura.append(media_pacote) 
    median_pacote = pacote['Temperatura'].median()  # calcula a m√©dia da coluna 'temperatura' do pacote atual
    median_temperatura.append(median_pacote)     
    
# Cria um eixo x com os √≠ndices dos pacotes
indices_pacotes = range(len(pacotes))

# Plote o gr√°fico de linha
plt.plot(indices_pacotes, medias_temperatura,color='b',label='M√©dia')
plt.plot(indices_pacotes, median_temperatura,color='y',label='Mediana')
plt.legend()
plt.title("M√âDIA AO DECORRER DOS 100 DIAS")
plt.xlabel("DIAS")
plt.ylabel("TEMPERATURA")

"""Nos 3 casos a m√©dia, mediana e moda apresentaram comportamentos similares. Para a Pressao e Batimento eles decairam e para temperatura cresceram ao longo dos dias. Nos 3 graficos a mediana apresentou geralmente valores superiores a m√©dia.

A seguir os histogramas para dada variavel:
"""

#Histogramas
data[['Batimento','Pressao','Temperatura']].hist()

"""Observa-se pelos graficos que a distribui√ßao dos dados para o batimento e pressao sao parecidos e possuem uma assimetria √† direita. Em contrapartida, a distribui√ßao da temperatura √© mais simetrica, com um pico proximo ao centro e √© diferente das distribui√ßoes das demais variaveis. 

Pelos passos anteriores constatou-se que a mediana √© maior que a m√©dia. Isso pode ser observado sobretudo pela assimetria dos graficos de batimento e pressao √† direita.

Pelos histogramas observou-se os valores para cada uma das variaveis: 
* Batimento: Valores geralmente maiores de 60 e menores de 80. 
* Pressao: Valores geralmente maiores de 8 e menores ou iguais a 15. 
* Temperatura: Valores geralmente maiores que 36 e menores ou iguais a 37,5¬∞C.  

Considerando os intervalos de valores comumente adotados pela medicina, tem-se: 
* Batimento : de 50 a 100 bpm. 
* Pressao: de 9,6 a 12,8. 
* Temperatura: de 36 a 37,2¬∞C. 

Para a constru√ßao do sistema foi considerado os valores comumente adotados pela medicina. Pelo histograma observa-se que alguns valores ja trazem resultados de estados de alerta enquanto outros sao referentes a pacientes saudaveis.
"""

#Sistema considerando valores normais adotados na medicina 
def main():
  try:
    #entradas
    b, p, t = input("Digite o batimento, a pressao e a temperatura do paciente: ").split()
    #processamento 
    b, p, t = float(b), int(p), int(t)
    if (b < 50.0) or (b > 100.0):
      print("Alarme de emerg√™ncia")
    elif (p < 9.6) or (p > 12.8):
      print("Alarme de emerg√™ncia")
    elif (t < 36.0 ) or (t > 37.2):
      print("Alarme de emerg√™ncia")
    else: 
      print("O paciente esta saudavel!")
  except: 
    print("Numeros invalidos. Favor, repetir a opera√ßao!")


if __name__ == "__main__":
    main()

"""Por fim, o sistema √© capaz de classificar o paciente como saud√°vel ou emitir um alerta de caso o valor capturado para uma das vari√°veis n√£o esteja de acordo com os valores normais esperados para o paciente considerando os intervalos comumente adotados pela medicina. Observa-se que esses valores est√£o de acordo com os histogramas obtidos tamb√©m, englobando a maior parte dos valores medidos. 
Caso ocorra um erro de digita√ß√£o ou sejam digitados caracteres ao inv√©s de valores v√°lidos para a l√≥gica do sistema, o sistema apresenta a mensagem de n√∫meros inv√°lidos e solicita ao usu√°rio repetir a opera√ß√£o. 


"""